% Nicholas Giampetro, Jayden Slotnick, Craig Stenstrom, Jordan Sprague, Payton Glynn

% YOU NEED TO DOWNLOAD THE SYMBOLIC MATH TOOLS ADDON FOR HEAVISIDE FUNCTION
%% Part 2

clc;

Start = 0 ;     % Value analysis Starts at
End = 8 ;       % Value analysis ends at
step = 0.1 ;    % step size
X0 = 0 ;        % x(0) initial condition
Xdot0 = 0 ;     % x'(0) initial condition
omega = 2 ;     % omega value form the equation
xi = 0.05 ;     % XI value from the equation 
T0 = 1 ;        % Amplitude Value
a = 0 ;         % heaviside offset

% currently set from t = 0 to t = 8 with steps of 0.1 since that is what they wanted us to solve to
tSpan = steps(Start,End,step);

% sets the x(0) and x'(0) into a vector for the ode45 function
x0s = [X0,Xdot0];


% ode45 solves the ode and outputs the results to the console
[t,x45] = ode45(@(t,x) odeFun(t,x,T0,xi,omega,a),tSpan,x0s);

xRK2 = RK2(tSpan,x0s,T0,xi,omega,a);
fprintf('Numerical displacement solution using ode45: \n')
disp(x45)
fprintf('Numerical displacement solution using RK2: \n')
disp(xRK2)

% calculates the analytical solution at each point of t
xAna = exact(tSpan,omega,xi,T0,a);
xAnaVel(81,1) = 1;

% plots x against t based on the data generated by ode45
figure(1)
subplot(2,1,1)
plot(t,x45(:,1),'-o',t,xAna(:,1),'-X',t,xRK2(:,1),'-O')
title('Displacement vs Time')
xlabel('Time')
ylabel('Displacement')
legend('ode45','Analytical','RK2','Location','best')

% also sourced from mathworks website on ode45 and edited for this project
subplot(2,1,2)
plot(t,x45(:,2),'-o',t,xAna(:,2),'-X',t,xRK2(:,2),'-O')          %xAna(:,1) is displacement we would need to make an analytical function for the velocity 
title('Velocity vs Time')
xlabel('Time')
ylabel('Velocity')
legend('ode45','Analytical','RK2','Location','best')
% calculates the error between numerical and analytical soln'
errorOde45 = abs(x45-xAna)
errorRK2 = abs(xRK2-xAna)

% finds error between the exact soln and RK2 as the step size is increased
stps = 5 ;
errors = zeros(stps,1);
sSize = zeros(stps,1);
errRef = zeros(stps,1);
for s = 1:stps
    sSize(s) = .1/s;
    tSpan = steps(Start,End,sSize(s));
    tSpan0 = steps(Start,End,sSize(1));
    err = abs( RK2(tSpan,x0s,T0,xi,omega,a)-exact(tSpan,omega,xi,T0,a));
    errors(s,1) = err(end);
    errRef(s)=(sSize(s))^2;
    
end


% plots error against step size
figure(2)
plot(sSize,errors,'-O', sSize, errRef, '-x')
title('Error vs Step Size')
xlabel('Step Size')
ylabel('Error')

%% Part 3
%clc
%clear

% new inital conditons
Start = 0 ;     % Value analysis Starts at
End = 2 ;       % Value analysis ends at
step = 0.001 ;    % step size
X0 = 0 ;        % x(0) initial condition
Xdot0 = 0 ;     % x'(0) initial condition
omega = 100 ;     % omega value form the equation
xi = steps(0,2,.1) ;     % XI value range 
T0 = 1 ;        % Amplitude Value
a = 0 ;         % heaviside offset
Ac = .05;       % max design acceleration


% Time span for vibration damping
tSpan = steps(Start,End,step);

% sets the x(0) and x'(0) into a vector
x0s = [X0,Xdot0];
n=length(xi);
maxAccel=zeros(n:1); % declares max acceleration matrix 
safeAccel=zeros(n:1); % same but for safe max accel

% steps through different xi to see different max accel values
% thought about making this a function but you would need to pass so many
% values into it that I think its not worth it. You can if you want tho
for ii=1:(n)
Xi = xi(ii);
sv = RK2(tSpan, x0s,T0, Xi, omega, a); 
accel= xDoubleDot(tSpan, sv, T0, Xi, omega, a);
maxAccel(ii)=max(accel(Ac/step:length(tSpan)));
    if maxAccel(ii)<=Ac
         safeAccel(ii)=maxAccel(ii);
    end
end
%disp(safeAccel)

% plots xi vs maxAccel for the linear damping
figure(3)
subplot(2,1,1)
plot(xi, maxAccel)
title('xi vs Max Acceleration')
ylabel('Max Acceleration')
xlabel('xi')


maxAccelnon=zeros(n:1); % declares max acceleration matrix 
safeAccelnon=zeros(n:1);% again, same

% calculates the nonlinear damping finding the values of xi that get a max
% acceleration under 0.05
for ii=1:(n)
Xi = xi(ii);
sv = RK2NonLin(tSpan, x0s,T0, Xi, omega, a); 
accel= xDoubleDotNonLin(tSpan, sv, T0, Xi, omega, a);
maxAccelnon(ii)=max(accel(Ac/step:length(tSpan)));
    if maxAccelnon(ii)<=Ac
         safeAccelnon(ii)=maxAccelnon(ii);
    end
end

 %disp(safeAccelnon)

 % plots xi vs maxAccel for the linear damping
subplot(2,1,2)
plot(xi,maxAccelnon)           
title('xi vs Max Acceleration non Linerar Damping')
ylabel('Max Acceleration')
xlabel('xi')
 



%% Functions

% ode actually contains the ode parameters dydy(1) is y' and dydt(2) is y''
function dxdt = odeFun(t,x,A,B,C,D)                           % A is t0, B is xi, C is omega, D is a
  dxdt = zeros(2,1);                                          % idk what this does but i think it is important                                       
  dxdt(1) = x(2);                                             % enter x' in terms of x1 x2 and t here
  dxdt(2) = A * heaviside(t-D) - (C^2)*x(1) - 2*B*C*x(2);     % enter x'' in terms of x1 x2 and t here
end
% I sourced this function from the mathworks website on ode45 than edited
% Its math for this project
% Heaviside function comes from Symbolic math tools addon for MATLAB

% exact function calculates the solution based on the analytical results
function [analytical_displacement] = exact(t,w,z,t0,a)
    e = 2.71828;            % euler number
    H = heaviside(t-a);     % heaviside variable
    Wd = w*sqrt(1-z^2);     % Wd formula

    analytical_displacement(:,1) = ((t0.*H)/(w.^2))-((((t0.*e.^(-z.*w.*t)).*H).*(cos(Wd.*t)-(sin(Wd.*t).*z.*w/Wd)))/(w^2))-((2.*t0.*z.*H.*e.^(-z.*w.*t).*sin(Wd.*t))/(w.*Wd));
    % used derivative calculator to get the analytical velocity below
    analytical_displacement(:,2) = (H.*t0.*(w.^2.*z.^2+Wd^2).*e.^-(w.*z.*t).*sin(Wd.*t))/(Wd.*w.^2);
end


% Steps function creates the step matrix based on distance and step size
function span = steps(S,E,step)     
    num = ((E-S)/(step))+1;     
    span = linspace(S,E,num);
end


% calculates y1 and y2 and saves them into a matrix 
% this code might be one of the most spaghetti things I have made
% my italian ancestors would be proud, but I am disgusted with myself
function y = RK2(span,y0,a,b,c,d)   % A is t0, B is xi, C is omega, D is a

h = span(2) - span(1);          % gets the span size
t = span;                       % sets t to the span matrix
n = length(t);                  % determine the number of steps
y = zeros(n,2);                 % allocate the array for numerical solutions
y(1,:) = y0;                    % The first row of y is the initial condition
   

    for ii = 1:(n-1)            % the loop that runs the RK2 method to get the y1 y2 variables   
        
        k1 = h / 2 * y2Prime(t(ii), y(ii,1), y(ii,2),a,b,c,d);
        K = h / 2 * (y(ii,2) + k1 / 2);
        k2 = h / 2 * y2Prime((t(ii) + h / 2), (y(ii,1) + K), (y(ii,2) + k1),a,b,c,d);
        k3 = h / 2 * y2Prime((t(ii) + h / 2), (y(ii,1) + K), (y(ii,2) + k2),a,b,c,d);
        L = h * (y(ii,2) + k3);
        k4 = h / 2 * y2Prime((t(ii) + h), (y(ii,1) + L), (y(ii,2) + k3 * 2),a,b,c,d);


        y(ii+1,1) = y(ii,1) + h * (y(ii,2) + (k1 + k2 + k3) / 3);
        y(ii+1,2) = y(ii,2) + (k1 + 2 * k2 + 2 * k3 + k4) / 3;
    end
end

% This for bonus. Our RK2 function could have been better generalized so
% we wouldn't need to do this but this works so...
function y = RK2NonLin(span,y0,a,b,c,d)   % A is t0, B is xi, C is omega, D is a

h = span(2) - span(1);          % gets the span size
t = span;                       % sets t to the span matrix
n = length(t);                  % determine the number of steps
y = zeros(n,2);                 % allocate the array for numerical solutions
y(1,:) = y0;                    % The first row of y is the initial condition
   

    for ii = 1:(n-1)            % the loop that runs the RK2 method to get the y1 y2 variables   
        
        k1 = h / 2 * y2PrimeNonLin(t(ii), y(ii,1), y(ii,2),a,b,c,d);
        K = h / 2 * (y(ii,2) + k1 / 2);
        k2 = h / 2 * y2PrimeNonLin((t(ii) + h / 2), (y(ii,1) + K), (y(ii,2) + k1),a,b,c,d);
        k3 = h / 2 * y2PrimeNonLin((t(ii) + h / 2), (y(ii,1) + K), (y(ii,2) + k2),a,b,c,d);
        L = h * (y(ii,2) + k3);
        k4 = h / 2 * y2PrimeNonLin((t(ii) + h), (y(ii,1) + L), (y(ii,2) + k3 * 2),a,b,c,d);


        y(ii+1,1) = y(ii,1) + h * (y(ii,2) + (k1 + k2 + k3) / 3);
        y(ii+1,2) = y(ii,2) + (k1 + 2 * k2 + 2 * k3 + k4) / 3;
    end
end

% Acceleration/x double dot function
function A = xDoubleDot(span,x,a,b,c,d)   % A is t0, B is xi, C is omega, D is a

t = span;                       % sets t to the span matrix
n = length(t);                  % determine the number of steps
A = zeros(n,1);                 % allocate the array for numerical solutions
   

    for ii = 1:(n-1)            % the loop that solves for x double dot or acceleration    
       A(ii) = y2Prime(span(ii),x(ii,1),x(ii,2),a,b,c,d);
    end
end

% Acceleration/x double dot non linear function (bonus)
function A = xDoubleDotNonLin(span,x,a,b,c,d)   % A is t0, B is xi, C is omega, D is a

t = span;                       % sets t to the span matrix
n = length(t);                  % determine the number of steps
A = zeros(n,1);                 % allocate the array for numerical solutions
   

    for ii = 1:(n-1)            % the loop that solves for x double dot/acceleration    
       A(ii) = y2PrimeNonLin(span(ii),x(ii,1),x(ii,2),a,b,c,d);
    end
end


%this is needed for the RK2 function, all part of the spaghetti recipe
%(does as the name sugests, finds y2prime)
function y2p = y2Prime(t,y1,y2,A,B,C,D)                 % A is t0, B is xi, C is omega, D is a
    y2p = A * heaviside(t-D) - (C^2)*y1 - 2*B*C*y2;     %x2prime function
end


% bonus
function y2pn = y2PrimeNonLin(t,y1,y2,A,B,C,D) % A is t0, B is xi, C is omega, D is a
    k=5*10^7;
    y2pn = A * heaviside(t-D) - (C^2)*y1 - 2*B*C*y2*(1-k*y1^2);     %nonlin fun
end